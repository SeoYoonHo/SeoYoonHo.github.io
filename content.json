{"pages":[],"posts":[{"title":"kinesis 중복레코드 처리(atleast once)","text":"Kiensis란?Kinesis는 실시간으로 데이터 스트림을 수집, 처리, 분석해주는 AWS 서비스이다. 데이터 스트림 수집 및 저장 샤드의 수를 조절하여 스트림을 얼마나 받을지 조절할 수 있음 데이터 중복이 일어나는 이유애플리케이션에 레코드가 두 번 이상 전달되는 주된 이유는 두가지로 나눌 수 있다. 생산자 재시도 소비자 재시도 각각의 경우에 어떤 이유로 일어나는지 알아보자 생산자 재시도생산자재시도가 일어나는 가장 큰 이유는 네트워크 이슈문제일 가능성이 크다Kiensis 스트림에서 승인을 받기 전에 네트워크 관련 시간초과가 발생한다면 생산자는 레코드가 스트림에 전달되었는지 알 수 없다이러한 경우 동일한 데이터에 대해 PutRecord를 2번 이상 호출 할 수있다.(최대 3번까지 호출가능)중복을 철저히 방지해야하는 애플리케이션은 처리할 때 레코드에 기본키를 포함시켜서 처리해줘야 한다. 소비자 재시도사실 생산자 재시도보다는 소비자 재시도가 훨씬 더 많이 발생한다다음과 같은 경우에 동일한 샤읃의 레코드 프로세서가 중복실행된다 작업자가 예기치 않게 종료된 경우 작업자 인스턴스가 추가 또는 제거된 경우 샤드가 병합 또는 분할된 경우 애플리케이션이 배포된 경우 설명이 모호할 수 있으니 구체적인 예를 통해 흐름을 살펴보자샤드 1개와 샤드를 처리하는 작업자 1개가 있다고 가정해보자마지막 체크포인트가 레코드 번호 10000에 있다는 가정하에 다음의 이벤트 흐름을 살펴보자 작업자가 샤드에서 다음 레코드 배치(레코트 10001부터 20000까지)를 읽습니다 그런 다음 작업자가 레코드 배치를 연결된 레코드 프로세서로 전달합니다 레코드 프로세서가 데이터를 집계하고 Amazon S3 파일을 생성하며 파일을 Amazon S3로 업로드합니다. 새로운 체크포인트가 발생하기 전에 작업자가 예기치 않게 종료됩니다 애플리케이션, 작업자 및 레코드 프로세서가 다시 시작됩니다 이제 작업자가 마지막으로 성공한 체크포인트(여기서는 10001)에서 읽기 시작합니다 따라서 레코드 10001 ~ 20000이 두번 이상 소비됩니다 운영 시스템 해결방법위와 같은 이유로 중복레코드에 대한 상황이 발생할 수 있음을 인지하고 현재 운영중인 시스템에서는 이에대한 해결방법을 세웠다실제로 운영중인 시스템에서 각 레코드의 항목들에는 그 항목을 유일하게 결정지을 수 있는 key값이 들어가있다결국 해당 data insert문에 대하여 merge into 문법을 사용하여 중복되지않게 적재되도록 처리하였다","link":"/2022/03/25/kinesis-%EC%A4%91%EB%B3%B5%EB%A0%88%EC%BD%94%EB%93%9C-%EC%B2%98%EB%A6%AC-atleast-once/"},{"title":"게시물","text":"#제목입니다 ###하이하이 이탤릭체는 &lt;em&gt; 입니다두껍게는 &lt;strong&gt; 입니다삭제선은 &lt;del&gt; 입니다밑줄은 &lt;u&gt; 입니다 이탤릭체는 별표 혹은 언더바 를 이용하세요두껍게는 별표두개 혹은 언더바두개 를 이용하세요이탤릭체와 두껍게 를 같이 사용할 수 있습니다 Array.map1array.map(callback[, thisArg])","link":"/2022/03/25/%EA%B2%8C%EC%8B%9C%EB%AC%BC/"},{"title":"RESTful API","text":"현대 애플리케이션은 대부분 프론트엔드라 부르는 클라이언트와 백엔드라 부르는 서버가 상호간 데이터를 주고받는 형태의 아키텍처를 가지고 있다. 이러한 구조의 가장 큰 특징중 하나는 서버와 클라이언트가 독립적으로 진화할 수 있다는 것이다.독립적으로 진화한다는 뜻은 각각의 업데이트 내용이 서로에게 영향을 미치지 않는 다는 것이다. 대표적인 예는 웹(web)이다. 웹 페이지의 변경이 브라우저에 영향을 미치지 못하고, 브라우저의 변경또한 페이지에 영향을 미치지 못한다. 서버와 클라이언트가 서로에게 영향을 끼치지 않고 독립적으로 진화하기 때문이다. 이러한 클라이언트 서버간의 독립적 진화를 위한 분산시스템 아키텍처로 가장 널리 쓰이는게 REST (Representatioin State Transfer) 아키텍쳐이다 REST(Representation State Transfer)REST는 2000년 HTTP의 주요 저자중 한 사람인 로이 필딩에 의해 제안되었다.그는 웹의 장점을 최대한 활용할 수 있는 아키텍처로써 REST를 발표하였고, 이를 통해 웹기술이 지속적으로 발전할 수 있게 되었다. 많은 사람들이 REST가 URI 패턴과 GET,POST 등의 HTTP Method 의 조합으로 이루어져 있다고 생각하지만,REST 아키텍처는 아키텍처라는 그 이름답게 결국 제약조건들의 집합이다. REST는 다음 여섯가지 제약조건을 가지고 있다. Client-Server Stateless Cache Uniform Interface Layered System Code On Demand(Optional) 각각에 대하여 살펴보도록 하자 Client-Server흔히들 이야기하는 서버와 클라이언트의 관계를 의미한다. 대부분 현대 애플리케이션은 서버-클라이언트 기반으로 만들어지고 사실상 이 구조를 벗어나는 것 자체가 힘든일이기 때문에 자연스럽게 만족되는 제약조건이라 할 수 있다. Stateless서버는 클라이언트의 각각의 요청을 모두 별개의 것으로 인식해야하고 이를 위해 모든 요청은 각자가 필요한 정보를 모두 담고 있어야 한다.요청 하나만 봐도 그 요청의 내용을 바로 알아볼 수 있어야 한다는 것이다. CacheHTTP라는 존재하는 프로토콜을 사용하기 때문에 웹에서 사용되는 기술인 캐시 역시 사용 가능하다.모든 서버응답은 캐시의 사용가능여부를 알고있어야하여, 캐시 사용을 고려한 설계가 필요하다. Uniform Interface구성요소들(서버,클라이언트)간의 인터페시으가 균일애햐 한다는 의미이다. 구체적으로 미디어 유형이나, 리소스 식별자 등을 구별하는 문법이 상호간 동일해야 한다는 뜻이다.이를 위해 REST는 네가지 제약사항을 제시하고 있다. identification of resources리소스를 식별하는 방법이 동일해야 한다. 흔히들 URI를 통해 리소스를 식별한다 manipulation of resources through representation리소스 자체를 전송하는 것이 아닌 리소스의 표현을 전송한다는 뜻. 서버에 있는 리소스가 아니라 현재 리소스의 상태를 반영하는 표현체를 전송함으로써 서버의 리소스 상태가 변해도 클라이언트에는 영향을 끼치지 못한다. self-descriptive messages요청이나 응답에는 스스로를 설명하는 정보를 포함하고 있어야 한다. 따라서 수신자는 이 정보를 통해 메시지를 이해할 수 있다. hypermedia as the engine of application state애플리케이션의 상태는 하이퍼미디어에 의해 변경된다는 것이다. 따라서 서버는 하이퍼미디어를 통해 다음 액션에 대한 선택지를 클라이언트에게 제공해야 한다. Layered System클라이언트 혹은 서버 모두 미들웨어 구성을 추가할 수 있는 구조를 가지고 있어야 한다는 의미이다. Code On Demand(Optional)서버는 클라이언트로 실행 가능한 프로그램을 전달할 수 있어야 한다. 쉽게 Javascript를 생각하면 된다. 그러나 이 조건은 선택사항이며 필수적이지는 않다. RESTful AIPRESTful API(REST API)란 위의 제약조건에 따르는 애플리케이션 프로그래밍 인터페이스를 뜻한다. 그러나 우리가 RESTful API라고 부르는 것들은 사실 REST하지 않은 경우가 대부분이다.특히 self-descriptve messages와 hypermedia as the engine of application state 원칙을 지키는 것이 상당히 까다로운 편이기 때문에 이 두원칙을 지키지 못하는 경우가 많다. 물론 로이 필딩은 이런 API를 REST라 불러선 안된다고 주장하지만 이미 많은 개발자들과 기업들은 REST 원칙을 지키지 못한 API들을 RESTful API라고 부르고 있다. 개인적인 생각원칙적인 REST 아키텍처 스타일을 알고있는 많은 사람들이 현대에 많은 글들과 회사에서 단지 몇가지 URL 규칙과 HTTP 메소드가 필요했을 뿐인 많은 사람들이 REST란 용어를 납치했다고까지 표현한다. 사실 개인적으론 이러한 논쟁이 머리아프게만 느껴지고 무슨 의미가 있나 싶기는 하지만, 이런 논쟁들이 좀 더 견고하고 표준화된 RESTful API 개념을 정립하는데 도움이 되겠거니 생각한다. 이런한 논쟁거리를 뒤로 하고 나는 결국 나만의 RESTful API를 정의 내렸다.HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)를 명시하고, HTTP Method(POST,GET,PUT,DELETE)를 통해 해당 자원에 대한 CRUD Opertaion을 적용한것논란이 끝나면 새로운 정의가 나올 수 있겠지만 일단은 이렇게 알고있는게 마음편하다.","link":"/2022/03/26/RESTful-API/"}],"tags":[{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"Kinesis","slug":"Kinesis","link":"/tags/Kinesis/"},{"name":"중복레코드 처리","slug":"중복레코드-처리","link":"/tags/%EC%A4%91%EB%B3%B5%EB%A0%88%EC%BD%94%EB%93%9C-%EC%B2%98%EB%A6%AC/"},{"name":"연습","slug":"연습","link":"/tags/%EC%97%B0%EC%8A%B5/"},{"name":"REful API","slug":"REful-API","link":"/tags/REful-API/"},{"name":"REST","slug":"REST","link":"/tags/REST/"},{"name":"STIS","slug":"STIS","link":"/tags/STIS/"},{"name":"CS","slug":"CS","link":"/tags/CS/"}],"categories":[{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"연습","slug":"연습","link":"/categories/%EC%97%B0%EC%8A%B5/"},{"name":"Kinesis","slug":"AWS/Kinesis","link":"/categories/AWS/Kinesis/"},{"name":"RESTful API","slug":"CS/RESTful-API","link":"/categories/CS/RESTful-API/"}]}