{"pages":[],"posts":[{"title":"kinesis 중복레코드 처리(atleast once)","text":"Kiensis란?Kinesis는 실시간으로 데이터 스트림을 수집, 처리, 분석해주는 AWS 서비스이다. 데이터 스트림 수집 및 저장 샤드의 수를 조절하여 스트림을 얼마나 받을지 조절할 수 있음 데이터 중복이 일어나는 이유애플리케이션에 레코드가 두 번 이상 전달되는 주된 이s유는 두가지로 나눌 수 있다. 생산자 재시도 소비자 재시도 각각의 경우에 어떤 이유로 일어나는지 알아보자 생산자 재시도생산자재시도가 일어나는 가장 큰 이유는 네트워크 이슈문제일 가능성이 크다Kiensis 스트림에서 승인을 받기 전에 네트워크 관련 시간초과가 발생한다면 생산자는 레코드가 스트림에 전달되었는지 알 수 없다이러한 경우 동일한 데이터에 대해 PutRecord를 2번 이상 호출 할 수있다.(최대 3번까지 호출가능)중복을 철저히 방지해야하는 애플리케이션은 처리할 때 레코드에 기본키를 포함시켜서 처리해줘야 한다. 소비자 재시도사실 생산자 재시도보다는 소비자 재시도가 훨씬 더 많이 발생한다다음과 같은 경우에 동일한 샤읃의 레코드 프로세서가 중복실행된다 작업자가 예기치 않게 종료된 경우 작업자 인스턴스가 추가 또는 제거된 경우 샤드가 병합 또는 분할된 경우 애플리케이션이 배포된 경우 설명이 모호할 수 있으니 구체적인 예를 통해 흐름을 살펴보자샤드 1개와 샤드를 처리하는 작업자 1개가 있다고 가정해보자마지막 체크포인트가 레코드 번호 10000에 있다는 가정하에 다음의 이벤트 흐름을 살펴보자 작업자가 샤드에서 다음 레코드 배치(레코트 10001부터 20000까지)를 읽습니다 그런 다음 작업자가 레코드 배치를 연결된 레코드 프로세서로 전달합니다 레코드 프로세서가 데이터를 집계하고 Amazon S3 파일을 생성하며 파일을 Amazon S3로 업로드합니다. 새로운 체크포인트가 발생하기 전에 작업자가 예기치 않게 종료됩니다 애플리케이션, 작업자 및 레코드 프로세서가 다시 시작됩니다 이제 작업자가 마지막으로 성공한 체크포인트(여기서는 10001)에서 읽기 시작합니다 따라서 레코드 10001 ~ 20000이 두번 이상 소비됩니다 운영 시스템 해결방법위와 같은 이유로 중복레코드에 대한 상황이 발생할 수 있음을 인지하고 현재 운영중인 시스템에서는 이에대한 해결방법을 세웠다실제로 운영중인 시스템에서 각 레코드의 항목들에는 그 항목을 유일하게 결정지을 수 있는 key값이 들어가있다결국 해당 data insert문에 대하여 merge into 문법을 사용하여 중복되지않게 적재되도록 처리하였다","link":"/2022/03/25/kinesis-%EC%A4%91%EB%B3%B5%EB%A0%88%EC%BD%94%EB%93%9C-%EC%B2%98%EB%A6%AC-atleast-once/"},{"title":"게시물","text":"#제목입니다 ###하이하이 이탤릭체는 &lt;em&gt; 입니다두껍게는 &lt;strong&gt; 입니다삭제선은 &lt;del&gt; 입니다밑줄은 &lt;u&gt; 입니다 이탤릭체는 별표 혹은 언더바 를 이용하세요두껍게는 별표두개 혹은 언더바두개 를 이용하세요이탤릭체와 두껍게 를 같이 사용할 수 있습니다 Array.map1array.map(callback[, thisArg]) blockquote","link":"/2022/03/25/%EA%B2%8C%EC%8B%9C%EB%AC%BC/"},{"title":"RESTful API","text":"현대 애플리케이션은 대부분 프론트엔드라 부르는 클라이언트와 백엔드라 부르는 서버가 상호간 데이터를 주고받는 형태의 아키텍처를 가지고 있다. 이러한 구조의 가장 큰 특징중 하나는 서버와 클라이언트가 독립적으로 진화할 수 있다는 것이다.독립적으로 진화한다는 뜻은 각각의 업데이트 내용이 서로에게 영향을 미치지 않는 다는 것이다. 대표적인 예는 웹(web)이다. 웹 페이지의 변경이 브라우저에 영향을 미치지 못하고, 브라우저의 변경또한 페이지에 영향을 미치지 못한다. 서버와 클라이언트가 서로에게 영향을 끼치지 않고 독립적으로 진화하기 때문이다. 이러한 클라이언트 서버간의 독립적 진화를 위한 분산시스템 아키텍처로 가장 널리 쓰이는게 REST (Representatioin State Transfer) 아키텍쳐이다 REST(Representation State Transfer)REST는 2000년 HTTP의 주요 저자중 한 사람인 로이 필딩에 의해 제안되었다.그는 웹의 장점을 최대한 활용할 수 있는 아키텍처로써 REST를 발표하였고, 이를 통해 웹기술이 지속적으로 발전할 수 있게 되었다. 많은 사람들이 REST가 URI 패턴과 GET,POST 등의 HTTP Method 의 조합으로 이루어져 있다고 생각하지만,REST 아키텍처는 아키텍처라는 그 이름답게 결국 제약조건들의 집합이다. REST는 다음 여섯가지 제약조건을 가지고 있다. Client-Server Stateless Cache Uniform Interface Layered System Code On Demand(Optional) 각각에 대하여 살펴보도록 하자 Client-Server흔히들 이야기하는 서버와 클라이언트의 관계를 의미한다. 대부분 현대 애플리케이션은 서버-클라이언트 기반으로 만들어지고 사실상 이 구조를 벗어나는 것 자체가 힘든일이기 때문에 자연스럽게 만족되는 제약조건이라 할 수 있다. Stateless서버는 클라이언트의 각각의 요청을 모두 별개의 것으로 인식해야하고 이를 위해 모든 요청은 각자가 필요한 정보를 모두 담고 있어야 한다.요청 하나만 봐도 그 요청의 내용을 바로 알아볼 수 있어야 한다는 것이다. CacheHTTP라는 존재하는 프로토콜을 사용하기 때문에 웹에서 사용되는 기술인 캐시 역시 사용 가능하다.모든 서버응답은 캐시의 사용가능여부를 알고있어야하여, 캐시 사용을 고려한 설계가 필요하다. Uniform Interface구성요소들(서버,클라이언트)간의 인터페시으가 균일애햐 한다는 의미이다. 구체적으로 미디어 유형이나, 리소스 식별자 등을 구별하는 문법이 상호간 동일해야 한다는 뜻이다.이를 위해 REST는 네가지 제약사항을 제시하고 있다. identification of resources리소스를 식별하는 방법이 동일해야 한다. 흔히들 URI를 통해 리소스를 식별한다 manipulation of resources through representation리소스 자체를 전송하는 것이 아닌 리소스의 표현을 전송한다는 뜻. 서버에 있는 리소스가 아니라 현재 리소스의 상태를 반영하는 표현체를 전송함으로써 서버의 리소스 상태가 변해도 클라이언트에는 영향을 끼치지 못한다. self-descriptive messages요청이나 응답에는 스스로를 설명하는 정보를 포함하고 있어야 한다. 따라서 수신자는 이 정보를 통해 메시지를 이해할 수 있다. hypermedia as the engine of application state애플리케이션의 상태는 하이퍼미디어에 의해 변경된다는 것이다. 따라서 서버는 하이퍼미디어를 통해 다음 액션에 대한 선택지를 클라이언트에게 제공해야 한다. Layered System클라이언트 혹은 서버 모두 미들웨어 구성을 추가할 수 있는 구조를 가지고 있어야 한다는 의미이다. Code On Demand(Optional)서버는 클라이언트로 실행 가능한 프로그램을 전달할 수 있어야 한다. 쉽게 Javascript를 생각하면 된다. 그러나 이 조건은 선택사항이며 필수적이지는 않다. RESTful APIRESTful API(REST API)란 위의 제약조건에 따르는 애플리케이션 프로그래밍 인터페이스를 뜻한다. 그러나 우리가 RESTful API라고 부르는 것들은 사실 REST하지 않은 경우가 대부분이다. 특히, self-descriptve messages와 hypermedia as the engine of application state 원칙을 지키는 것이 상당히 까다로운 편이기 때문에 이 두원칙을 지키지 못하는 경우가 많다. 물론 로이 필딩은 이런 API를 REST라 불러선 안된다고 주장하지만 이미 많은 개발자들과 기업들은 REST 원칙을 지키지 못한 API들을 RESTful API라고 부르고 있다. 개인적인 생각원칙적인 REST 아키텍처 스타일을 알고있는 많은 사람들이 현대에 많은 글들과 회사에서 단지 몇가지 URL 규칙과 HTTP 메소드가 필요했을 뿐인 많은 사람들이 REST란 용어를 납치했다고까지 표현한다. 사실 개인적으론 이러한 논쟁이 머리아프게만 느껴지고 무슨 의미가 있나 싶기는 하지만, 이런 논쟁들이 좀 더 견고하고 표준화된 RESTful API 개념을 정립하는데 도움이 되겠거니 생각한다. 이런한 논쟁을 뒤로 하고 나는 결국 나만의 RESTful API를 정의 내렸다. Restful API란 HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)를 명시하고, HTTP Method(POST,GET,PUT,DELETE)를 통해 해당 자원에 대한 CRUD Opertaion을 적용한것.논란이 끝나면 새로운 정의가 나올 수 있겠지만 일단은 이렇게 알고있는게 마음편하다.","link":"/2022/03/26/RESTful-API/"},{"title":"객체지향 5원칙(SOLID)","text":"2000년대 초 로버트 마틴이 명명한 객체 지향 프로그래밍의 다섯가비 기본원칙을 마이클 페더스가 원칙의 앞글자를 따서 다시 SOLID라고 소개하였다.SOLID의 5대원칙은 다음과 같다. 단일 책임 원칙(Single Responsibility Principle) 개방 폐쇄 원칙(Open/Cloed Principle) 리스코프 치환 원칙(Liskov Subsitution Principle) 인터페이스 분리 원칙(Interface Segregation Principle) 의존관계 역전 원칙(Dependency Inversion Principle) 이 다섯가지 원칙애 대해 자세히 알아보도록 하자 단일 책임 원칙 : SRP(Single Responsibility Principle)모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화 해야함을 일컫는다.다시말해 클래스가 제공하는 모든 서비스는 단 하나의 책임을 수행하는데 집중되어야 한다는 뜻이다. SRP를 지키지 못하는 경우1234567891011121314public class 강아지 { final static Boolean 수컷 = true; final static Boolean 암컷 = false; Boolean 성별; void 소변보다() { if (this.성별 == 수컷) { // 한쪽 다리를 들고 소변을 보다. } else { // 뒷다리 두 개를 굽혀 앉은 자세로 소변을 본다. } }} 메소드에서 수컷, 암컷의 경우를 모두 구현하려고 하여 단일 책임 원칙을 위반하고 있는것을 볼 수 있다. SRP를 지키는 경우123456789101112131415abstract class 강아지 { abstract void 소변보다();}class 수컷강아지 extends 강아지 { void 소변보다() { // 한쪽 다리를 들고 소변을 본다. }}class 암컷강아지 extends 강아지 { void 소변보다() { // 뒷다리 두 개로 앉은 자세로 소변을 본다. }} 그래서 위와 같이 추상클래스를 두고 각각의 클래스가 자신의 특징에 맞게 메소드를 구현해서 사용하는것으로 리팩토링 할 수 있다. 개방 폐쇄의 원칙 : OCP(Open Closed Principle)개방-폐쇄 원칙은 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 프로그래밍 원칙이다. 다시 말하면 요구사항의 변경이나 추가사항이 발생하더라도, 기존 구성요소는 수정이 일어나지 말아야 하며 쉽게 확장이 가능하여 재사용할 수 있어야 한다는 뜻이다.로버트 마틴은 OCP는 관리가 용이하고 재사용 가능한 코드를 만드는 기반이며, OCP를 가능케 하는 중요한 메커니즘은 추상화와 다형성이라고 설명한다. 비밀번호 암호화를 강화해야한다는 요구사항이 새롭게 들어왔다고 가정하자. 비밀번호 암호화를 강화하기 위해 다음과 같이 SHA-256알고리즘을 사용하는 새로운 PasswordEncoder를 생성하였다. 1234567public class SHA256PasswordEncoder{ public String encryptPassword(final String pw){ // SHA-256 암호화 메소드 }} 그리고 새로운 비밀번호 암호화 정책을 적용하려고 봤더니 UserService를 다음과 같이 수정해주어야 한다는 것이 발견되었다. 1234567public class UserService{ private final SHA256PasswordEncoder passwordEncoder; ...} 해당 코드의 문제가 보이는가?위 코드는 나중에 비밀번호 암호화 정책을 변경해야 한다는 요구사항이 온다면 또 다시 UserService에 변경이 필요해진다. 이는 기존의 코드를 수정하지 않아야 하는 개방 폐쇄 원칙에 위배된다.결국 이러한 문제를 해결하고 개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 한다. 12345678910111213141516171819202122public interface PasswordEncoder { String encryptPassword(final String pw); }public class SHA256PasswordEncoder implements PasswordEncoder { @Override public String encryptPaswword(final String pw){ ... }}public class UserService{ private final PasswordEncoder passwordEncoder; public void adduser(final String email, final String pw){ final String encryptedPassword = passwordEncoder.encryptPassword(pw); ... }} 개방 폐쇄 원칙이 본질적으로 얘기하고자 하는것은 결국 추상화이다. 이는 런타임 의존성과 컴파일 의존성이 객체 지향 프로그래밍에서는 동일하지 않다는 것을 의미한다. 리스코프 치환 원칙 : LSP(Liskov Substitution Principle)리스코프 치환 원칙은 1988년 바바라 리스코프가 올바른 상속 관계의 특징을 정의하기 위해 발표한 내용으로, 하위 클래스는 상위클래스의 모든 기능들을 수행 할 수 있어야함을 의미한다.즉 상위클래스을 사용하는 객체는 그 객체가 하위클래스로 변경되어도 문제없이 수행되어야 한다. 정말 당연한 원칙이지만 실무에서 좀처럼 지켜지지 않는 원칙중에 하나이다. 대부분의 경우 상위클래스의 메소드를 override하면서 문제가 발생하게 된다. 상위클래스의 기존 메소드를 하위클래스에서 잘못 수정하게 되면서 문제가 생기게 되는것이다. LSP를 잘 지키기 위해서는 override를 안하면 되는것이지만, 이는 절대적인 방법이 아니다.결국 상속을 할 떄 override가 필요하다면 상위클래스의 기능을 충실히 수행하고 기능의 추가만 신중하게 수행하면 된다. LSP는 결국 현재 하위클래스가 상위클래스의 기존 메소드의 의미를 해지지 않는지 신중히 고민을 하고 올바르게 상속하라는 의미이다. 인터페이스 분리의 원칙 : ISP(Interface Segregation Principle)인터페이스 분리 원칙은 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다. 다시 말하면 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙이다. 하나의 큰 인터페이스를 상속받기보다는 인터페이스를 구체적이고 작은 단위들로 분리시켜 꼭 필요한 인터페이스만 구현하다는 의미이다. SRP가 클래스의 단일책임을 강조했다면 ISP는 인터페이스의 단일책임을 강조한다. 의존 역전 원칙 : DIP(Dependency Inversion Principle)의존 역전의 원칙은 다음과 같은 내용을 담고 있다. 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야한다. 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야한다. 의존 역전 원칙은 클래스 사이에는 의존관계가 존재하기 마련이지만, 구체적인 클래스에 의존하지말고 추상화에 의존하는 설계를 의미한다. 우리는 위의 예시들을 살펴보면서 의존 역전 원칙에 준수하도록 코드를 수정한 경험이 있다. 바로 OCP를 설명하기 위해 살펴봤던 SimplePasswordEncoder 예제가 DIP에 부합하는 리팩토링 과정이다. 예시에서 살펴보았든 의존 역전 원칙(DIP)는 개방 폐쇄 원칙(OCP)와 밀접한 관련이 있으며, 의존 역전 원칙이 위배되면 개방 폐쇄 원칙 역시 위배되게 될 가능성이 높다.","link":"/2022/03/26/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-SOLID/"},{"title":"DB 트랜잭션","text":"트랜잭션이란?트랜잭션은 하나의 작업을 수행하기 위해 필요한 데이터베이스의 연산들을 모아놓은 것으로, 데이터베이서에서 논리적인 작업의 단위이며 장애가 발생했을 때 데이터를 복구하는 작업의 단위이다. 현업에서 쓰이는 개념으로 쉽게 설명하면 트랜잭션 단위로 데이터의 커밋과 롤백이 이루어진다. 커밋(Commit) : 모든 부분작업이 정상적으로 완료되면 이 변경사항을 한꺼번에 DB에 반영한다. 롤백(Rollback) : 부분 작업이 실패하면 트랜잭션 실행 전으로 되돌린다.이때, 모든 연산을 취소하지 않고 정해진 부분까지만 되돌리고 싶을 때 사용하는 것이 savepoint이다. 트랜잭션의 특징(ACID)트랜잭션이 성공적으로 처리되어 데이터베이스의 무결성과 일관성을 보장하기 위해 4가지 특징을 만족해야한다. 4가지 특징은 다음과 같다. 원자성(Atomicity) 일관성(Consistency) 격리성(Isolation) 지속성(Durability) 각각의 특징에 대하여 자세하게 알아보자 원자성 (Atomicity) 트랜잭션을 구성하는 연산들은 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다는 all or nothing 방식이다. 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야한다. 트랜잭션 내의 모든 명령은 반드시 완벽하게 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생한다면 트랜잭션 전부가 취소되어야 한다. 일관성 (Consistency) 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 예를 들어 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다. 독립성 (Isolation) 트랜잭션 수행시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다. 예를 들어 은행 관리자는 이체 작업을 하는 도중 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수없다. 성능 관련 이유로 인해 이 특성은 가장 유연성이 있는 제약조건이다. 지속성 (Durability) 성공적으로 수행된 트랜잭션은 영구적으로 반영되어야 함을 의미한다. 트랜잭션 연산보통 DB를 사용 할 때, 쿼리를 날리는 시점에 데이터베이스에 반영된다고 생각한다. 하지만 데이터베이스에 반영되는 시점은 트랜잭션 연산이 성공적으로 완료되는 시점에 실제 데이터베이스에 반영이 된다. 트랜잭션 연산에는 크게 두가지 과정이 있다. commit 연산 트랜잭션이 성공적으로 수행되었음을 선언(작업 완료) commit 연산이 실행 된 후에야 트랜잭션의 수행결과가 데이터베이스에 반영되어 일관된 상태를 지속적으로 유지. commit 연산의 실행을 통해 트랜잭션의 수행이 성공적으로 완료되었음을 선언하고 결과를 최종 데이터베이스에 반영. rollback 연산 트랜잭션이 수행을 실패했음을 선언(작업 취소) rollback 연산이 실행되면 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고 트랜잭션이 수행되기 전의 상태로 돌아간다. 트랜잭션 수행 도중 일부 연산이 처리되지 못한 상황에서는 rollback 연산을 실행하여 트랜잭션의 수행이 실패했음을 선언하고, 모순되지 않도록 데이터베이스를 트랜잭션 수행 전의 일관된 상태로 되돌려야한다. 트랜잭션 상태트랜잭션은 위와 같은 연산을 수행할 떄 크게 5가지의 상태가 존재하고 상태 처리 과정은 아래 그림과 같다 활성(Active) : 트랜잭션이 정상적으로 실행중인 상태실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태완료(Committed) : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태","link":"/2022/03/26/DB-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"title":"모니터링 시스템(Prometheus, Grafana)","text":"2018년 유지보수중이던 시스템이 기존 NT 서버에서 AWS로 모든 인프라를 옮기는 대공사를 진행하게 되었다.인프라 전면전환 작업은 2년 가까운 시간이 되어서야 반영이 되었고, 2020년경부터 새로운 AWS인프라 위의 시스템을 유지보수하기 시작했다. 각종 문제들이 많이 생기기 시작했지만 가장 시급한 문제는 모니터링 시스템의 부재였다. 현재 내가 운영하고 있는 시스템은 실시간 대용량 트랜잭션을 처리하는 시스템으로, 장애발생시 5분 이내에 복구조치가 되도록 계약되어 있었고, 이를 위해서 모니터링 체계 구축은 필수적인 작업이었다. 많은 조사가 있었고 결국 우리는 프로메테우스와 그라파나라는 오픈소스를 사용하여 모니터링 체계를 구축하기 시작했다. 왜 프로메테우스인가?회사생활을 하다보면, 아니 개발자로서 살아가다보면 기술을 이유없이 의미없이 가져다 쓰는 경우가 굉장히 많다. 얼마전 지인으로부터 모니터링 시스템에 관해 이야기하다 프로메테우스를 선택한 이유에 대한 질문을 받게되었다. 답변을 하기 위해 횡설수설 프로메테우스의 장점에 대해 이야기했지만, 막상 생각해보니 시스템을 구축할 당시 많은 고민을 해보고 선택하지는 않았음을 깨달았다. 물론 그 당시 나름의 이유가 있었지만 잘 기억이 안나기에 다시 한번 리마인드 하기 위해 관련 내용을 정리해보고자 한다. Prometheus 장점프로메테우스 Github에서 설명하고 있는 장점들은 다음과 같습니다. 다차원 데이터 모델 가능 다차원 데이터 모델을 활용할 수 있는 유연한 쿼리언어(PromQL) 분산 스토리지에서 어떠한 의존성도 없음 모든 데이터는 HTTP(REST) Pull 기반으로 가져온다. 물론 Push도 가능함 모니터링 타겟은 프로메테우스의 YAML 설정값을 통해 Discovery 많은 장점들이 있지만 결국 프로메테우스의 가장 큰 특징이자 장점은 Pull방식의 모니터링 오픈소스라는 점이다. Pull 방식이란 대상 애플리케이션의 Exporter Enpoint로부터 데이터를 scrape 해오는 방식을 말한다.이 방식 덕분에 모니터링 설정을 Data Backend에서 효율적으로 관리할 수 있고, 혹시라도 Prometheus 장애 발생시에도 애플리케이션에 지장이 가지 않을수가 있다.위와 같은 장점들이 결국 프로메테우스를 선택하게 된 가장 큰 이유가 되었다. 물론 프로메테우스가 장점만 존재하는것은 아니다. 이제부터는 프로메테우스의 한계점에 대해 알아보고자 한다. Prometheus 한계점 클러스터링 구조에 대한 미지원 프로메테우스는 좋은 모니터링 시스템이긴 하지만 결정적인 문제점들이 있다. 그 첫번째가 바로 클러스터링 구조에 대한 미지원 문제이다. 이는 확장성과 가용성에 문제를 가져오게 된다. 확장성시스템에서 모니터링 할 대상들이 많지 않다면 하나의 프로메테우스 서버로 감당이 가능하겠지만, 볼륨이 늘어난다면 버거워지기 마련이다. 이 문제를 해결하는 방법으로 Federation 이라는 방법을 사용한다. 프로메테우스 인스턴스를 여러개 기동한 다음, 중앙에 다른 프로메테우스로부터 메트릭을 수집하는 중앙 집중 프로메테우를 놓는 방식이고, 데이터 양에 대한 문제는 데이터 해상도를 줄이거나 평균, 합등의 대표값을 사용해서 해결 할 수 있다. 가용성프로메테우스는 하나의 서버로 기동되기 때문에 그 서버가 장애로 내려갈 경우, 그 시간동안은 매트릭을 수집할 수 없다는 단점을 가지고 있다. 이를 해결하기 위해서는 프로메테우스 인스턴스를 두개 이상 띄운 다음 같은 대상 시스템으로부터 매트릭을 수집하는 방식인데 이렇게 되면 해당 문제를 해결 할 수 있기는 하다. 위의 아키텍쳐들은 역시 클러스터링의 대용일 뿐 제대로 되어 보이지는 않는다. 이를 해결하기 위해 오픈소스 타노스가 나왔지만 이는 나중에 다뤄보도록 한다. 오래 된 값 저장 프로메테우스의 다른 문제점 중 하나는 로컬 디스크를 사용하기 때문에 일정 기간이 지나 오래된 데이터는 삭제가 된다는 점이다. 그래서 오래된 데이터에 대한 조회가 불가능하다. 물론 이 문제에 대한 해결책 또한 오픈소스 타노스를 이용한다면 어느정도 해결이 되겠지만 이는 다루는 내용을 벗어나므로 다루지 않겠다. 이러한 한계점들이 존재하지만 현재 운영시스템에서는 위와 같은 한계들을 인정하고서라도 프로메테우스의 장점을 높이 쳐줬기에 선택하게 되었다.현 시스템이 그렇게 크지 않기때문에 클러스터링 구조는 필요가 없을것이라 판단했고, 오래된 값 또한 아쉽긴 하지만 실시간 모니터링에 초점을 두다보니 크게 문제가 되지 않았다. 왜 그라파나인가?","link":"/2022/03/28/%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EC%8B%9C%EC%8A%A4%ED%85%9C-Prometheus-Grafana/"}],"tags":[{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"Kinesis","slug":"Kinesis","link":"/tags/Kinesis/"},{"name":"중복레코드 처리","slug":"중복레코드-처리","link":"/tags/%EC%A4%91%EB%B3%B5%EB%A0%88%EC%BD%94%EB%93%9C-%EC%B2%98%EB%A6%AC/"},{"name":"연습","slug":"연습","link":"/tags/%EC%97%B0%EC%8A%B5/"},{"name":"REful API","slug":"REful-API","link":"/tags/REful-API/"},{"name":"REST","slug":"REST","link":"/tags/REST/"},{"name":"STIS","slug":"STIS","link":"/tags/STIS/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"SOLID","slug":"SOLID","link":"/tags/SOLID/"},{"name":"객체지향 5원칙","slug":"객체지향-5원칙","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99/"},{"name":"객체지향","slug":"객체지향","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5/"},{"name":"트랜잭션","slug":"트랜잭션","link":"/tags/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"모니터링 시스템","slug":"모니터링-시스템","link":"/tags/%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EC%8B%9C%EC%8A%A4%ED%85%9C/"},{"name":"Prometheus","slug":"Prometheus","link":"/tags/Prometheus/"},{"name":"Grafana","slug":"Grafana","link":"/tags/Grafana/"},{"name":"Expoter","slug":"Expoter","link":"/tags/Expoter/"}],"categories":[{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"연습","slug":"연습","link":"/categories/%EC%97%B0%EC%8A%B5/"},{"name":"Kinesis","slug":"AWS/Kinesis","link":"/categories/AWS/Kinesis/"},{"name":"RESTful API","slug":"CS/RESTful-API","link":"/categories/CS/RESTful-API/"},{"name":"객체지향 5원칙(SOLID)","slug":"CS/객체지향-5원칙-SOLID","link":"/categories/CS/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EC%9B%90%EC%B9%99-SOLID/"},{"name":"DB 트랜잭션","slug":"CS/DB-트랜잭션","link":"/categories/CS/DB-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98/"},{"name":"모니터링","slug":"모니터링","link":"/categories/%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81/"},{"name":"Prometheus&#x2F;Grafana","slug":"모니터링/Prometheus-Grafana","link":"/categories/%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81/Prometheus-Grafana/"}]}